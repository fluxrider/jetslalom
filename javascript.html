<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Jet Slalom Resurrected</title>
<script src="js/M.js"></script>
<script src="js/C.js"></script>
<script src="js/Game.js"></script>
<script>
function go_fullscreen() { const canvas_element = document.getElementById("canvas"); if(canvas_element.requestFullScreen) { canvas_element.requestFullScreen(); } else if(canvas_element.webkitRequestFullScreen) { canvas_element.webkitRequestFullScreen(); } else if(canvas_element.mozRequestFullScreen) { canvas_element.mozRequestFullScreen(); } canvas_element.focus(); }
function currentTimeMillis() { var now = new Date(); return Date.UTC(now.getUTCFullYear(), now.getUTCMonth(), now.getUTCDate(),  now.getUTCHours(), now.getUTCMinutes(), now.getUTCSeconds(), now.getUTCMilliseconds()); }
// Code from Esailija at https://stackoverflow.com/questions/11866781/how-do-i-convert-an-integer-to-a-javascript-color
function c2css(num) { num >>>= 0; var b = num & 0xFF, g = (num & 0xFF00) >>> 8, r = (num & 0xFF0000) >>> 16, a = ( (num & 0xFF000000) >>> 24 ) / 255 ; return "rgba(" + [r, g, b, a].join(",") + ")"; }

var target_dt = 55;
var delay = target_dt;
var t0, t1;
var original_filter;
var paused = false;
var ship_animation = 0;

var mouse_held = false;
var mouse_x, mouse_y;
function on_mouse_down(e) {
  mouse_x = e.offsetX;
  mouse_y = e.offsetY;
  mouse_held = true;
}
function on_mouse_up(e) {
  mouse_held = false;
}
function on_mouse_move(e) {
  if(mouse_held) {
    mouse_x = e.offsetX;
    mouse_y = e.offsetY;
  }
}

var key_left = false, key_right = false;
var key_a = false, key_d = false;
var key_j = false, key_l = false;
function on_key_down(e) {
  if(e.repeat) return;
  // key:   ArrowUp ArrowDown w s f h + - ' ' Enter c t p
  if(e.key == "ArrowLeft") key_left = true;
  if(e.key == "ArrowRight") key_right = true;
  if(e.key == "a") key_a = true;
  if(e.key == "d") key_d = true;
  if(e.key == "j") key_j = true;
  if(e.key == "l") key_l = true;
}
function on_key_up(e) {
  if(e.key == "ArrowLeft") key_left = false;
  if(e.key == "ArrowRight") key_right = false;
  if(e.key == "a") key_a = false;
  if(e.key == "d") key_d = false;
  if(e.key == "j") key_j = false;
  if(e.key == "l") key_l = false;
}

var gamepad = {
  param_dpad_diag_count: true,
  start: false, select: false,
  south: false, north: false, west: false, east: false,
  up: false, down: false, left: false, right: false,
  left_shoulder: false, right_shoulder: false,
  l3: false, r3: false,
  left_trigger: 0, right_trigger: 0,
  lx: 0, ly: 0, rx: 0, ry: 0,
  n_start: false, n_select: false,
  n_south: false, n_north: false, n_west: false, n_east: false,
  n_up: false, n_down: false, n_left: false, n_right: false,
  n_left_shoulder: false, n_right_shoulder: false,
  n_l3: false, n_r3: false,
  available: false,
  poll: function () {
    this.n_start = this.start; this.n_select = this.select;
    this.n_south = this.south; this.n_north = this.north; this.n_west = this.west; this.n_east = this.east;
    this.n_up = this.up; this.n_down = this.down; this.n_left = this.left; this.n_right = this.right;
    this.n_left_shoulder = this.left_shoulder; this.n_right_shoulder = this.right_shoulder;
    this.n_l3 = this.l3; this.n_r3 = this.r3;
    for(const pad of navigator.getGamepads()) { if(!pad) continue;
      // see gamepad mapping at https://w3c.github.io/gamepad/#remapping
      if(pad.mapping == "standard") {
        this.available = true;
        this.south = pad.buttons[0].pressed;
        this.east = pad.buttons[1].pressed;
        this.west = pad.buttons[2].pressed;
        this.north = pad.buttons[3].pressed;
        this.left_shoulder = pad.buttons[4].pressed;
        this.right_shoulder = pad.buttons[5].pressed;
        this.left_trigger = pad.buttons[6].value; // note: I was not able to test these, I get nothing from 6 or 7 on my gamepad. omg 6,7.
        this.right_trigger = pad.buttons[7].value;
        this.select = pad.buttons[8].pressed;
        this.start = pad.buttons[9].pressed;
        this.l3 = pad.buttons[10].pressed;
        this.r3 = pad.buttons[11].pressed;
        this.up = pad.buttons[12].pressed;
        this.down = pad.buttons[13].pressed;
        this.left = pad.buttons[14].pressed;
        this.right = pad.buttons[15].pressed;
        this.lx = pad.axes[0];
        this.ly = pad.axes[1];
        this.rx = pad.axes[2];
        this.ry = pad.axes[3];
      }
    }
    this.n_start = this.start != this.n_start; this.n_select = this.select != this.n_select;
    this.n_south_maybe = this.south_maybe != this.n_south_maybe; this.n_north_maybe = this.north_maybe != this.n_north_maybe; this.n_west_maybe = this.west_maybe != this.n_west_maybe; this.n_east_maybe = this.east_maybe != this.n_east_maybe;
    this.n_up = this.up != this.n_up; this.n_down = this.down != this.n_down; this.n_left = this.left != this.n_left; this.n_right = this.right != this.n_right;
    this.n_left_shoulder = this.left_shoulder != this.n_left_shoulder; this.n_right_shoulder = this.right_shoulder != this.n_right_shoulder;
    this.n_l3 = this.l3 != this.n_l3; this.n_r3 = this.r3 != this.n_r3;
  }
};

var ship_0, ship_1;
const explosion = new Audio('res/explosion.wav');
var game = new Game();

async function app_start() {
  const canvas_element = document.getElementById("canvas");
  canvas_element.onmousedown = on_mouse_down;
  canvas_element.onmouseup = on_mouse_up;
  canvas_element.onmousemove = on_mouse_move;
  canvas_element.onkeydown = on_key_down; // the key events only work if the html canvas has a tabindex
  canvas_element.onkeyup = on_key_up;
  canvas_element.focus();
  const canvas = canvas_element.getContext("2d");
  original_filter = canvas.filter;

  // load assets
  ship_0 = new Image(); ship_0.src = "res/jiki.gif"; await ship_0.decode();
  ship_1 = new Image(); ship_1.src = "res/jiki2.gif"; await ship_1.decode();
  
  game.startGame(false, false);

  // start draw loop
  t0 = currentTimeMillis(); t1 = t0;
  app_draw();
}

function app_draw() {
  t0 = t1; t1 = currentTimeMillis(); let dt = t1 - t0;
  const canvas_element = document.getElementById("canvas");
  const width = canvas_element.width; const height = canvas_element.height;
  const canvas = canvas_element.getContext("2d");
  const logical_width = 320; const logical_height = 200;
  canvas.imageSmoothingEnabled = false;

  // input
  gamepad.poll(); let dead_zone = .05;
  let ship_left = key_a || key_j || key_left || (mouse_held && mouse_x < width / 2) || gamepad.left || gamepad.left_shoulder || gamepad.lx < -dead_zone || gamepad.rx < -dead_zone || gamepad.left_trigger > dead_zone;
  let ship_right = key_d || key_l || key_right || (mouse_held && mouse_x > width / 2) || gamepad.right || gamepad.right_shoulder || gamepad.lx > dead_zone || gamepad.rx > dead_zone || gamepad.right_trigger > dead_zone;

  if(game.title_mode && paused) paused = false;
  if(!paused) {
    game.tick(ship_left, ship_right);
  }
  
  // the svg trick to disable anti-alias of shapes does not work on an offscreen surface, so I scale the real one instead
  canvas.filter = 'url(#remove-alpha)';
  canvas.scale(4,4); draw_scene(canvas, logical_width, logical_height);
        
  // text overlay
  canvas.filter = original_filter; canvas.scale(.25,.25);
  canvas.fillStyle = "rgb(0 0 0)";
  canvas.font = "48px serif";
  const msg = ship_left + " " + ship_right;
  const fm = canvas.measureText(msg);
  canvas.fillText(msg, 0, height);
  canvas.fillText(msg, width - fm.width, height);
  canvas.fillText(msg, 0, fm.actualBoundingBoxAscent);

  // request another draw later
  if(dt > target_dt) { delay--; } // framerate too low, try faster
  if(dt < target_dt) { delay++; } // framerate too high, try slower
  if(delay < 1) delay = 1;
  window.setTimeout(app_draw, delay);
}

// draw game primitives
function drawFace(canvas, width, height, face) {
  let points = face.points;
  let d1 = (points[1]).x - (points[0]).x;
  let d2 = (points[1]).y - (points[0]).y;
  let d3 = (points[2]).x - (points[0]).x;
  let d4 = (points[2]).y - (points[0]).y;
  let f = Math.abs(d1 * d4 - d2 * d3) / face.maxZ;
  drawPolygon(canvas, width, height, C.drgb(C.fr(face.rgb)*f, C.fg(face.rgb)*f, C.fb(face.rgb)*f), points);
}
function drawPolygon(canvas, width, height, color, points) {
  let d1 = width / 320.0;
  let d2 = height / 200.0;
  canvas.beginPath();
  for(b = 0; b < points.length; b++) {
    let point = points[b];
    let d3 = 120.0 / (1.0 + 0.6 * point.z);
    let d4 = game.nowCos * point.x + game.nowSin * (point.y - 2.0);
    let d5 = -game.nowSin * point.x + game.nowCos * (point.y - 2.0) + 2.0;
    let x  = (d4 * d1 * d3) + width / 2;
    let y = (d5 * d2 * d3) + height / 2;
    if(b == 0) canvas.moveTo(x,y);
    else canvas.lineTo(x,y);
  }
  canvas.closePath();
  canvas.fillStyle = c2css(color);
  canvas.fill();
}
function draw_obstacle(canvas, width, height, o) {
  drawFace(canvas, width, height, o.faces[0]);
  drawFace(canvas, width, height, o.faces[1]);
}


function draw_scene(canvas, width, height) {
  canvas.fillStyle = c2css(game.rounds[game.round].getSkyRGB());
  canvas.fillRect(0, 0, width, height);
  drawPolygon(canvas, width, height, game.rounds[game.round].getGroundRGB(), game.ground_points);
  for(i = 0; i < game.obstacles.length; i++) draw_obstacle(canvas, width, height, game.obstacles[i]);
  ship_animation++;
  if(!game.title_mode) {
    let y = 24 * height / 200;
    image = this.ship_animation % 4 > 1? ship_1 : ship_0;
    if(ship_animation % 12 > 6) y = 22 * height / 200;
    if(game.score < 200) y = (12 + game.score / 20) * height / 200;
    let image_scale = (int)(width * 0.7 * 120 / 1.6 / 320); let ship_w = image_scale * 2; let ship_h = image_scale / 4;
    let ship_x = (width / 2) - ship_w/2, ship_y = height - y;
    if(game.damaged < 10) canvas.drawImage(image, ship_x, ship_y, ship_w, ship_h);
    if(game.damaged > 0) {
      if(game.damaged <= 20) {
        if(game.damaged == 1) { explosion.play(); }
        canvas.fillStyle = c2css(C.rgb(255, 255 - game.damaged * 12, 240 - game.damaged * 12));
        let i = game.damaged * 8 * width / 320;
        let j = game.damaged * 4 * height / 200;
        let left = (width / 2) - i;
        let top = 186 * height / 200 - j;
        // TODO this.scene_c.drawOval(left, top, left + i * 2, top + j * 2, p);
      }
    }
  }
}

</script>
</head>
<body onload="app_start();">
<p><button onclick="go_fullscreen();">Go Fullscreen</button>&emsp;<a href="https://github.com/fluxrider/jetslalom">Github</a></p>
<canvas id="canvas" width="1280" height="800" style="border: 3px solid black; image-rendering: pixelated;" tabindex="1"></canvas>
<!-- hack to disable anti-alias drawing: https://stackoverflow.com/questions/4261090/html5-canvas-and-anti-aliasing -->
<svg width="0" height="0" style="position:absolute;z-index:-1;"><defs><filter id="remove-alpha" x="0" y="0" width="100%" height="100%"><feComponentTransfer><feFuncA type="discrete" tableValues="0 1"></feFuncA></feComponentTransfer></filter></defs></svg>
</body>
</html>